The 64 Core Threshold Processor Groups on Windows https://bitsum.com/general/the64corethresholdprocessorgroupsandwindows/ 這是軟體Process Lasso的文章 買AMD 3990X要注意 (電蝦點 Windows上有個64核心的限制 超過會增加processor groups 產生的問題之一 就是不容易把效能用盡 如果應用程式不知道這個限制的話 專業用途還是別用Windows (連server版都別用 拿來數框框就好 知道我英不出多核和關HT的原因了吧(誤 延伸閱讀: https://docs.microsoft.com/enus/windows/win32/procthread/processorgroups 翻譯本文(雖然翻譯完我更懂了但是還是建議直接看原文): TL; DR 微軟通過添加processor group 解決 (原文hacked)了對64個以上logical CPU cores的支援。除非編寫應用程式利用多個processor group（processor group aware），否則將僅調度到單個處理器組(ex: 128 logical processors = group1 group2;單個意謂著只有group1)。請參閱我們新的groupextend項目，以通過調度補充處 理器組的線程來使不知道processor group的應用程式充分利用CPU，Process Lasso現在 也提供了此功能。 隨著具有64個以上邏輯CPU核心的系統變得常見，了解Windows的一些基本限制也變得重要 起來。當初設計Windows NT時，使用64位bitmask表示整個系統中的CPU affinities。對 於當時使用的單核CPU來說，這似乎是足夠的。現在，64個核心的限制已經不夠了。為了 解決這個問題 Windows 2008 R2導入了processor group，以支持64個以上的邏輯CPU核心。每個組最多 具有64個核心。現有的API和系統功能可以繼續接受64位CPU affinity bitmasks，因為它 們隱式地在單個處理器組上運行。這意味著，應用程式在沒有相應的處理的情況下，每個 process都限於一個處理器組，最多不超過64個邏輯核心。 因此，您在“Process Lasso”中看到的process（應用程式）CPU affinity是應用程式的 預設處理器組。作業系統就是這樣應對的。因此，如果您擁有96個邏輯核心系統，則將看 到多達48個邏輯核心的應用程序CPU affinity。如果應用程式在第一組上，則該CPU affinity將代表前48個邏輯核心。如果應用程式在第二組中，則CPU affinity將代表後48 個邏輯核心。 預設處理器組是以輪循方式分配的，通常是persession分配，因為CPU affinity是 繼承的，因此session load最終大致分配在處理器組之間。應用程式啟動後，將無法更改 其預設的處理器組。 但是，可以將應用程式中的各個threads手動分配給該應用程序的預設組以外的組。 SetThreadGroupAffinity和其它thread API支援處理器組的規範。這樣，一個應用程式的 threads可以在多個處理器組上運行，但是必須手動分配它們。理想情況下，這是由應用 程式開發人員實現的，因為了解threads在做什麼以及應將threads放置在何處非常重要 。 將threads分配給應用程式預設設置以外的其它組後，該應用程式將成為一個多組。但是 ，新threads將繼續使用應用程式啟動時分配的預設組。 當應用程式的threads跨越多個處理器組時，由於該應用程式的CPU affinity bitmask僅 適用於應用程序式啟動時分配的預設處理器組，因此可能會造成混淆。 處理器組通常由少於64個核心組成，因為它們不能跨越NUMA節點，並且必須平均劃分。擁 有不同大小的處理器組是奇怪的，這導致應用程式根據分配給它們的處理器組而獲得更多 或更少的核心。 因此，在具有72個邏輯CPU核心，分為兩個NUMA節點的系統上，將創建兩個處理器組，每 個處理器組具有36個邏輯CPU核心。 這創建了一個有趣的場景，其中具有多達64個核心的Windows系統可能允許應用程式訪問 比具有64個以上核心的系統更多的核心。(Ex:64 (64 x 2) > 72(36 x 4) Z > B...原文 後面有個更清楚的例子) 為了演示其影響，我們想像一個不知道處理器組的應用程式，恰當地命名為 UnawareOfGroupsApp.exe。 如您所見，在48核系統上，我們的不知道procssor group的應用程序可以訪問48個CPU核 ，而在72核系統上只能訪問36個如果這種情況下出現問題，則您的選擇如下： 1.禁用超線程/ SMT，以將邏輯核心數減少到64個或更少，從而導致整體計算能力下降 。由於單個處理器組包括所有可用的內核，因此這將允許組不知道的進程使用更多的內核 。 2.請與應用程式開發人員聯繫，以使他們對其進行修改以使其能夠識別processor group。 3.與Bitsum聯繫以了解我們能為您做什麼。我們可以適應團體不了解的應用程序。更新 ：請參閱下面的groupextend工具。 使用這種設計，用戶應該在升級硬體之前檢查應用程式的組支持，並嘗試選擇CPU核心計 數為64的倍數的硬體，因為這將得到最大的處理器組大小。 。winter:4c8t。n。intel：核心太多沒有必要。還好4c8t沒有這個問題。就是一個超市有128個收銀台，但經理關了64個收銀台。，又強迫1個店員要負責兩個收銀台。AMD就專門破壞和諧，沒那麼多核哪會有人知道有這個。問題。開兩個32核的虛擬機裝win10就可以了嗎。裝Linux就好。少核和關HT？呵呵 二十年前60核心電腦設計老早考慮。的東西又被提出來了。問一下 買3990 跑3DMAX 不用Windows 能用啥系統。3D軟體只要去炎上一下，廠商就會改出來了。文章也太舊XD。沒有AMD神奇膠水  不會有人注意。到windows有限制。但64核對正常人也超級多了。要寫到能用盡64核的程式其實用GPGPU會更快吧。很多東西通用GPU是還算不出來的，。硬要CPU的CODE改成GPU，。先看老闆願不願意加薪，。文章也講了手動指定thread就不用太在意64核的限制。大家都知道GPGPU快 重點是 你願意寫嗎？。GPGPU這麼屌 AMD Fusion就不會死這麼難看 懂?。fusion現在反而是i皇努力的目標